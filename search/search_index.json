{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introdu\u00e7\u00e3o O Tupy (Toolkit for Understanding Python) \u00e9 uma interface gr\u00e1fica que permite criar programas em Python que podem ser visualizados e manipulados de forma interativa. Por isso, ele \u00e9 \u00fatil para o ensino e aprendizagem de programa\u00e7\u00e3o, em particular do paradigma de Programa\u00e7\u00e3o Orientada a Objetos. O Tupy foi desenvolvido na linguagem Python e usa o pacote Tkinter para construir sua interface gr\u00e1fica.","title":"Introdu\u00e7\u00e3o"},{"location":"#introducao","text":"O Tupy (Toolkit for Understanding Python) \u00e9 uma interface gr\u00e1fica que permite criar programas em Python que podem ser visualizados e manipulados de forma interativa. Por isso, ele \u00e9 \u00fatil para o ensino e aprendizagem de programa\u00e7\u00e3o, em particular do paradigma de Programa\u00e7\u00e3o Orientada a Objetos. O Tupy foi desenvolvido na linguagem Python e usa o pacote Tkinter para construir sua interface gr\u00e1fica.","title":"Introdu\u00e7\u00e3o"},{"location":"atualizacao/","text":"Atualiza\u00e7\u00e3o de tela O Tupy atualiza a tela cerca de 30 vezes por segundo e, com isso, \u00e9 capaz de exibir anima\u00e7\u00f5es. Para isso, \u00e9 necess\u00e1rio alterar o estado dos objetos da cena ao longo do tempo. Para isso, voc\u00ea pode implementar uma fun\u00e7\u00e3o update() ou, ainda, implementar um m\u00e9todo update() nas classes dos objetos que devem ser alterados. Fun\u00e7\u00e3o update A fun\u00e7\u00e3o update() \u00e9 chamada a cada quadro da anima\u00e7\u00e3o. Por exemplo: from tupy import * estrela1 = Image('star.png') estrela2 = Image('star.png') def update(): estrela1.angle += 5 run(globals()) Nesse exemplo, a fun\u00e7\u00e3o update() \u00e9 chamada a cada quadro da anima\u00e7\u00e3o. A cada quadro, o \u00e2ngulo da primeira estrela \u00e9 incrementado em 5 graus. Isso faz com que a estrela gire continuamente. M\u00e9todo update Outra forma de atualizar o estado dos objetos \u00e9 implementar um m\u00e9todo update() nas classes dos objetos que devem ser alterados. Por exemplo: from tupy import * class Star(Image): def update(self): self.angle += 5 estrela1 = Star('star.png') estrela2 = Star('star.png') run(globals()) Nesse caso, n\u00e3o \u00e9 necess\u00e1rio definir uma fun\u00e7\u00e3o update() al\u00e9m do m\u00e9todo update() da classe Star . A cada quadro, o m\u00e9todo update() de cada estrela \u00e9 chamado. Isso faz com que ambas as estrelas girem continuamente.","title":"Atualiza\u00e7\u00e3o"},{"location":"atualizacao/#atualizacao-de-tela","text":"O Tupy atualiza a tela cerca de 30 vezes por segundo e, com isso, \u00e9 capaz de exibir anima\u00e7\u00f5es. Para isso, \u00e9 necess\u00e1rio alterar o estado dos objetos da cena ao longo do tempo. Para isso, voc\u00ea pode implementar uma fun\u00e7\u00e3o update() ou, ainda, implementar um m\u00e9todo update() nas classes dos objetos que devem ser alterados.","title":"Atualiza\u00e7\u00e3o de tela"},{"location":"atualizacao/#funcao-update","text":"A fun\u00e7\u00e3o update() \u00e9 chamada a cada quadro da anima\u00e7\u00e3o. Por exemplo: from tupy import * estrela1 = Image('star.png') estrela2 = Image('star.png') def update(): estrela1.angle += 5 run(globals()) Nesse exemplo, a fun\u00e7\u00e3o update() \u00e9 chamada a cada quadro da anima\u00e7\u00e3o. A cada quadro, o \u00e2ngulo da primeira estrela \u00e9 incrementado em 5 graus. Isso faz com que a estrela gire continuamente.","title":"Fun\u00e7\u00e3o update"},{"location":"atualizacao/#metodo-update","text":"Outra forma de atualizar o estado dos objetos \u00e9 implementar um m\u00e9todo update() nas classes dos objetos que devem ser alterados. Por exemplo: from tupy import * class Star(Image): def update(self): self.angle += 5 estrela1 = Star('star.png') estrela2 = Star('star.png') run(globals()) Nesse caso, n\u00e3o \u00e9 necess\u00e1rio definir uma fun\u00e7\u00e3o update() al\u00e9m do m\u00e9todo update() da classe Star . A cada quadro, o m\u00e9todo update() de cada estrela \u00e9 chamado. Isso faz com que ambas as estrelas girem continuamente.","title":"M\u00e9todo update"},{"location":"classes/","text":"Outros tipos de objetos O Tupy permite criar outros tipos de objetos al\u00e9m de imagens. Por exemplo, \u00e9 poss\u00edvel criar ret\u00e2ngulos, c\u00edrculos, ovais e textos. Ret\u00e2ngulo Para criar um Ret\u00e2ngulo: Rectangle(x, y, width, height, outline = 'black', fill = ''): Onde: x, y \u00e9 a posi\u00e7\u00e3o do canto superior esquerdo do ret\u00e2ngulo width, height \u00e9 o tamanho do ret\u00e2ngulo (largura e altura) outline \u00e9 a cor da borda do ret\u00e2ngulo (por padr\u00e3o, preta) fill \u00e9 a cor do preenchimento do ret\u00e2ngulo (por padr\u00e3o, transparente) Os atributos outline e fill s\u00e3o cores, que podem ser representadas da seguinte forma: '' (string vazia): transparente #RGB ou #RRGGBB : cor em RGB, onde R, G e B s\u00e3o n\u00fameros hexadecimais de 0 a F Um dos nomes de cores reconhecidos pelo Tk Exemplo de uso: from tupy import * r = Retangulo(10, 10, 100, 50, outline = 'red', fill = 'yellow') run(globals()) C\u00edrculo e oval Para criar um oval ou um c\u00edrculo: Oval(x, y, width, height, outline = 'black', fill = ''): Os par\u00e2metros s\u00e3o os mesmos da classe Rectangle (ver acima). Texto Para criar um texto: Label(text, x, y, font = 'Arial 20', color = 'black', anchor = 'nw'): Onde: text \u00e9 o texto a ser exibido (string) x, y \u00e9 a posi\u00e7\u00e3o do texto (ver o par\u00e2metro anchor abaixo) font \u00e9 a fonte do texto (por padr\u00e3o, Arial tamanho 20) color \u00e9 a cor do texto (por padr\u00e3o, preta) anchor \u00e9 o ponto de refer\u00eancia do texto. Pode ser um dos seguintes valores: 'nw' : canto superior esquerdo 'n' : centro superior 'ne' : canto superior direito 'w' : centro esquerdo 'center' : centro 'e' : centro direito 'sw' : canto inferior esquerdo 's' : centro inferior 'se' : canto inferior direito Exemplo de uso: from tupy import * t = Label(10, 10, 'Ol\u00e1 mundo!') run(globals())","title":"Outros tipos de objetos"},{"location":"classes/#outros-tipos-de-objetos","text":"O Tupy permite criar outros tipos de objetos al\u00e9m de imagens. Por exemplo, \u00e9 poss\u00edvel criar ret\u00e2ngulos, c\u00edrculos, ovais e textos.","title":"Outros tipos de objetos"},{"location":"classes/#retangulo","text":"Para criar um Ret\u00e2ngulo: Rectangle(x, y, width, height, outline = 'black', fill = ''): Onde: x, y \u00e9 a posi\u00e7\u00e3o do canto superior esquerdo do ret\u00e2ngulo width, height \u00e9 o tamanho do ret\u00e2ngulo (largura e altura) outline \u00e9 a cor da borda do ret\u00e2ngulo (por padr\u00e3o, preta) fill \u00e9 a cor do preenchimento do ret\u00e2ngulo (por padr\u00e3o, transparente) Os atributos outline e fill s\u00e3o cores, que podem ser representadas da seguinte forma: '' (string vazia): transparente #RGB ou #RRGGBB : cor em RGB, onde R, G e B s\u00e3o n\u00fameros hexadecimais de 0 a F Um dos nomes de cores reconhecidos pelo Tk Exemplo de uso: from tupy import * r = Retangulo(10, 10, 100, 50, outline = 'red', fill = 'yellow') run(globals())","title":"Ret\u00e2ngulo"},{"location":"classes/#circulo-e-oval","text":"Para criar um oval ou um c\u00edrculo: Oval(x, y, width, height, outline = 'black', fill = ''): Os par\u00e2metros s\u00e3o os mesmos da classe Rectangle (ver acima).","title":"C\u00edrculo e oval"},{"location":"classes/#texto","text":"Para criar um texto: Label(text, x, y, font = 'Arial 20', color = 'black', anchor = 'nw'): Onde: text \u00e9 o texto a ser exibido (string) x, y \u00e9 a posi\u00e7\u00e3o do texto (ver o par\u00e2metro anchor abaixo) font \u00e9 a fonte do texto (por padr\u00e3o, Arial tamanho 20) color \u00e9 a cor do texto (por padr\u00e3o, preta) anchor \u00e9 o ponto de refer\u00eancia do texto. Pode ser um dos seguintes valores: 'nw' : canto superior esquerdo 'n' : centro superior 'ne' : canto superior direito 'w' : centro esquerdo 'center' : centro 'e' : centro direito 'sw' : canto inferior esquerdo 's' : centro inferior 'se' : canto inferior direito Exemplo de uso: from tupy import * t = Label(10, 10, 'Ol\u00e1 mundo!') run(globals())","title":"Texto"},{"location":"encapsulamento/","text":"Encapsulamento A classe Image possui atributos p\u00fablicos, como x e y . Isso permite que o usu\u00e1rio altere a posi\u00e7\u00e3o da imagem diretamente pela interface do Tupy ou ent\u00e3o atrav\u00e9s de c\u00f3digo. Isso pode ser um problema quando criamos uma subclasse de Image , como Carro . \u00c9 desej\u00e1vel que o carro se mova apenas para frente e para tr\u00e1s, mas n\u00e3o para os lados. Para isso criamos m\u00e9todos como avanca e recua , que alteram a posi\u00e7\u00e3o do carro. O problema \u00e9 que, mesmo com esses m\u00e9todos, o usu\u00e1rio ainda consegue alterar a posi\u00e7\u00e3o do carro diretamente, fazendo-o andar para os lados ou teleportar-se para qualquer lugar da tela. Em Python, podemos esconder um membro de uma classe (atributo ou m\u00e9todo) dando-lhe um nome iniciado por _ . Com isso o membro deixa de ficar vis\u00edvel no ambiente do Tupy, obrigando o usu\u00e1rio a usar os m\u00e9todos da classe para alterar a posi\u00e7\u00e3o do carro. Membros cujo nome se inicia por _ s\u00e3o chamados de privados . (Observa\u00e7\u00e3o: o usu\u00e1rio at\u00e9 pode acessar membros privados se usar o console do Tupy, ent\u00e3o o uso de membros privados \u00e9 mais uma recomenda\u00e7\u00e3o para n\u00e3o acessar do que uma forma de seguran\u00e7a.) Classe BaseImage A classe BaseImage \u00e9 muito parecida com a classe Image , exceto que todos os seus atributos s\u00e3o privados: _x , _y , _file e _angle . N\u00e3o se deve instanciar objetos dessa classe diretamente, mas sim atrav\u00e9s de suas subclasses. As subclasses podem acessar os atributos privados da classe BaseImage atrav\u00e9s de m\u00e9todos. Exemplo: from tupy import * class Carro(BaseImage): def __init__(self): super().__init__('carro.png', 100, 100) def avanca(self): self._x += 10 def recua(self): self._x -= 10 No exemplo, os atributos n\u00e3o aparecem no ambiente Tupy, o que indica que o usu\u00e1rio n\u00e3o deve alter\u00e1-los diretamente. Apenas a posi\u00e7\u00e3o no eixo X pode ser alterada, e ainda assim, de forma controlada, de 10 em 10 pixels, atrav\u00e9s dos m\u00e9todos avanca e recua .","title":"Encapsulamento"},{"location":"encapsulamento/#encapsulamento","text":"A classe Image possui atributos p\u00fablicos, como x e y . Isso permite que o usu\u00e1rio altere a posi\u00e7\u00e3o da imagem diretamente pela interface do Tupy ou ent\u00e3o atrav\u00e9s de c\u00f3digo. Isso pode ser um problema quando criamos uma subclasse de Image , como Carro . \u00c9 desej\u00e1vel que o carro se mova apenas para frente e para tr\u00e1s, mas n\u00e3o para os lados. Para isso criamos m\u00e9todos como avanca e recua , que alteram a posi\u00e7\u00e3o do carro. O problema \u00e9 que, mesmo com esses m\u00e9todos, o usu\u00e1rio ainda consegue alterar a posi\u00e7\u00e3o do carro diretamente, fazendo-o andar para os lados ou teleportar-se para qualquer lugar da tela. Em Python, podemos esconder um membro de uma classe (atributo ou m\u00e9todo) dando-lhe um nome iniciado por _ . Com isso o membro deixa de ficar vis\u00edvel no ambiente do Tupy, obrigando o usu\u00e1rio a usar os m\u00e9todos da classe para alterar a posi\u00e7\u00e3o do carro. Membros cujo nome se inicia por _ s\u00e3o chamados de privados . (Observa\u00e7\u00e3o: o usu\u00e1rio at\u00e9 pode acessar membros privados se usar o console do Tupy, ent\u00e3o o uso de membros privados \u00e9 mais uma recomenda\u00e7\u00e3o para n\u00e3o acessar do que uma forma de seguran\u00e7a.)","title":"Encapsulamento"},{"location":"encapsulamento/#classe-baseimage","text":"A classe BaseImage \u00e9 muito parecida com a classe Image , exceto que todos os seus atributos s\u00e3o privados: _x , _y , _file e _angle . N\u00e3o se deve instanciar objetos dessa classe diretamente, mas sim atrav\u00e9s de suas subclasses. As subclasses podem acessar os atributos privados da classe BaseImage atrav\u00e9s de m\u00e9todos. Exemplo: from tupy import * class Carro(BaseImage): def __init__(self): super().__init__('carro.png', 100, 100) def avanca(self): self._x += 10 def recua(self): self._x -= 10 No exemplo, os atributos n\u00e3o aparecem no ambiente Tupy, o que indica que o usu\u00e1rio n\u00e3o deve alter\u00e1-los diretamente. Apenas a posi\u00e7\u00e3o no eixo X pode ser alterada, e ainda assim, de forma controlada, de 10 em 10 pixels, atrav\u00e9s dos m\u00e9todos avanca e recua .","title":"Classe BaseImage"},{"location":"entrada/","text":"Teclado e mouse Programas escritos para o Tupy podem responder a eventos de teclado e mouse. Para isso, \u00e9 necess\u00e1rio chamar m\u00e9todos espec\u00edficos dentro da fun\u00e7\u00e3o update() ou do m\u00e9todo update() de uma classe. Teclado O Tupy define uma vari\u00e1vel global keyboard , com tr\u00eas m\u00e9todos: keyboard.is_key_down(key) : retorna True se a tecla key est\u00e1 pressionada, ou False caso contr\u00e1rio keyboard.is_key_up(key) : retorna True se a tecla key n\u00e3o est\u00e1 pressionada, ou False caso contr\u00e1rio keyboard.is_key_just_down(key) : retorna True se a tecla key acabou de ser pressionada neste instante, ou False caso contr\u00e1rio O par\u00e2metro key \u00e9 uma string que representa uma tecla do teclado. Por exemplo, 'left' representa a tecla de seta para a esquerda, 'a' representa a tecla a , 'space' representa a barra de espa\u00e7o, etc. A lista completa de strings pode ser encontrada no manual do Tk Exemplo de uso: from tupy import * class Star(Image): def update(self): if keyboard.is_key_down('Left'): self.x -= 2 if keyboard.is_key_down('Right'): self.x += 2 if keyboard.is_key_just_down('space'): # volta para posi\u00e7\u00e3o inicial self.x = 20 self.y = 20 estrela = Star('star.png') estrela.x = 20 estrela.y = 20 run(globals()) Mouse O Tupy define uma vari\u00e1vel global mouse , com os seguintes membros: atributos x e y : definem a posi\u00e7\u00e3o do ponteiro do mouse, relativamente \u00e0 \u00e1rea de visualiza\u00e7\u00e3o da cena m\u00e9todo is_button_down() : retorna True se o bot\u00e3o do mouse est\u00e1 pressionado, ou False caso contr\u00e1rio m\u00e9todo is_button_just_down() : retorna True se o bot\u00e3o do mouse acabou de ser pressionado neste instante, ou False caso contr\u00e1rio Exemplo de uso: from tupy import * class Star(Image): def update(self): self.x = mouse.x self.y = mouse.y if mouse.is_button_just_down(): self.angle += 30 s = Star() run(globals())","title":"Teclado e mouse"},{"location":"entrada/#teclado-e-mouse","text":"Programas escritos para o Tupy podem responder a eventos de teclado e mouse. Para isso, \u00e9 necess\u00e1rio chamar m\u00e9todos espec\u00edficos dentro da fun\u00e7\u00e3o update() ou do m\u00e9todo update() de uma classe.","title":"Teclado e mouse"},{"location":"entrada/#teclado","text":"O Tupy define uma vari\u00e1vel global keyboard , com tr\u00eas m\u00e9todos: keyboard.is_key_down(key) : retorna True se a tecla key est\u00e1 pressionada, ou False caso contr\u00e1rio keyboard.is_key_up(key) : retorna True se a tecla key n\u00e3o est\u00e1 pressionada, ou False caso contr\u00e1rio keyboard.is_key_just_down(key) : retorna True se a tecla key acabou de ser pressionada neste instante, ou False caso contr\u00e1rio O par\u00e2metro key \u00e9 uma string que representa uma tecla do teclado. Por exemplo, 'left' representa a tecla de seta para a esquerda, 'a' representa a tecla a , 'space' representa a barra de espa\u00e7o, etc. A lista completa de strings pode ser encontrada no manual do Tk Exemplo de uso: from tupy import * class Star(Image): def update(self): if keyboard.is_key_down('Left'): self.x -= 2 if keyboard.is_key_down('Right'): self.x += 2 if keyboard.is_key_just_down('space'): # volta para posi\u00e7\u00e3o inicial self.x = 20 self.y = 20 estrela = Star('star.png') estrela.x = 20 estrela.y = 20 run(globals())","title":"Teclado"},{"location":"entrada/#mouse","text":"O Tupy define uma vari\u00e1vel global mouse , com os seguintes membros: atributos x e y : definem a posi\u00e7\u00e3o do ponteiro do mouse, relativamente \u00e0 \u00e1rea de visualiza\u00e7\u00e3o da cena m\u00e9todo is_button_down() : retorna True se o bot\u00e3o do mouse est\u00e1 pressionado, ou False caso contr\u00e1rio m\u00e9todo is_button_just_down() : retorna True se o bot\u00e3o do mouse acabou de ser pressionado neste instante, ou False caso contr\u00e1rio Exemplo de uso: from tupy import * class Star(Image): def update(self): self.x = mouse.x self.y = mouse.y if mouse.is_button_just_down(): self.angle += 30 s = Star() run(globals())","title":"Mouse"},{"location":"es/","text":"Entrada e sa\u00edda de texto toast(mensagem, duracao = 3000) Exibe uma mensagem na tela por um tempo determinado em milessegundos (por padr\u00e3o 3000). print(valor1, valor2, ...) Escreve valores na sa\u00edda padr\u00e3o (console). Os valores podem ser de qualquer tipo, mas devem ser convert\u00edveis para string. input(prompt = '') -> str Abre uma janela para o usu\u00e1rio digitar uma linha de texto e retorna o que foi digitado como string. Opcionalmente, pode-se exibir uma mensagem informativa (prompt) para o usu\u00e1rio.","title":"Entrada e sa\u00edda de texto"},{"location":"es/#entrada-e-saida-de-texto","text":"toast(mensagem, duracao = 3000) Exibe uma mensagem na tela por um tempo determinado em milessegundos (por padr\u00e3o 3000). print(valor1, valor2, ...) Escreve valores na sa\u00edda padr\u00e3o (console). Os valores podem ser de qualquer tipo, mas devem ser convert\u00edveis para string. input(prompt = '') -> str Abre uma janela para o usu\u00e1rio digitar uma linha de texto e retorna o que foi digitado como string. Opcionalmente, pode-se exibir uma mensagem informativa (prompt) para o usu\u00e1rio.","title":"Entrada e sa\u00edda de texto"},{"location":"exemplo/","text":"Primeiro exemplo Crie um script Python com o seguinte conte\u00fado: from tupy import * class Star(Image): def update(self): self.y += 2 star1 = Star() star2 = Star() star1.x = 100 star2.x = 200 run(globals()) Explica\u00e7\u00e3o A primeira linha importa o m\u00f3dulo tupy , que cont\u00e9m as classes e fun\u00e7\u00f5es necess\u00e1rias para criar programas interativos. As tr\u00eas linhas seguintes definem uma classe Star que herda da classe Image . A classe Image representa uma imagem que pode ser exibida na tela. A classe Star adiciona um m\u00e9todo update que \u00e9 chamado a cada quadro da anima\u00e7\u00e3o. Esse m\u00e9todo faz com que a estrela caia 2 pixels a cada quadro. As quatro linhas seguintes criam duas inst\u00e2ncias da classe Star e as posicionam na tela. Por fim, a \u00faltima linha abre a janela do Tupy e inicia a anima\u00e7\u00e3o. Executando Por fim, execute o script com o interpretador Python. Isso deve abrir o Tupy e mostrar duas estrelas caindo.","title":"Primeiro exemplo"},{"location":"exemplo/#primeiro-exemplo","text":"Crie um script Python com o seguinte conte\u00fado: from tupy import * class Star(Image): def update(self): self.y += 2 star1 = Star() star2 = Star() star1.x = 100 star2.x = 200 run(globals())","title":"Primeiro exemplo"},{"location":"exemplo/#explicacao","text":"A primeira linha importa o m\u00f3dulo tupy , que cont\u00e9m as classes e fun\u00e7\u00f5es necess\u00e1rias para criar programas interativos. As tr\u00eas linhas seguintes definem uma classe Star que herda da classe Image . A classe Image representa uma imagem que pode ser exibida na tela. A classe Star adiciona um m\u00e9todo update que \u00e9 chamado a cada quadro da anima\u00e7\u00e3o. Esse m\u00e9todo faz com que a estrela caia 2 pixels a cada quadro. As quatro linhas seguintes criam duas inst\u00e2ncias da classe Star e as posicionam na tela. Por fim, a \u00faltima linha abre a janela do Tupy e inicia a anima\u00e7\u00e3o.","title":"Explica\u00e7\u00e3o"},{"location":"exemplo/#executando","text":"Por fim, execute o script com o interpretador Python. Isso deve abrir o Tupy e mostrar duas estrelas caindo.","title":"Executando"},{"location":"grupos/","text":"Grupos de objetos BaseGroup e Group s\u00e3o classes de conveni\u00eancia que permitem agrupar objetos do Tupy em um \u00fanico objeto. Por exemplo, se voc\u00ea quiser mover um grupo de objetos, basta mover o grupo que os cont\u00e9m. A classe BaseGroup possui membros privados e foi feita para ser estendida por outras classes, enquanto a classe Group funciona da mesma forma, mas com membros p\u00fablicos. BaseGroup Al\u00e9m dos atributos e m\u00e9todos herdados de BaseTupyObject , BaseGroup define os seguintes atributos e m\u00e9todos: _objects : lista com todos os objetos contidos no BaseGroup . Essa lista n\u00e3o deve ser alterada diretamente, e sim atrav\u00e9s dos m\u00e9todos _add , _remove e _clear . _add(obj) : adiciona um objeto \u00e0 lista de objetos contidos no BaseGroup . _remove(obj) : remove um objeto da lista de objetos contidos no BaseGroup . _clear() : remove todos os objetos da lista de objetos contidos no BaseGroup . Exemplo de uso de BaseGroup : from tupy import * class Constelacao(BaseGroup): def __init__(self): super().__init__(x, y) self._add(Image('estrela.png', 100, 100)) self._add(Image('estrela.png', 150, 150)) def update(self): self._x += 1 self._y += 1 cons = Constelacao() run(globals()) Group Group possui os mesmos atributos e m\u00e9todos, por\u00e9m p\u00fablicos. Al\u00e9m disso, Group possui x e y p\u00fablicos. O construtor de Group recebe, opcionalmente, uma lista de objetos que ser\u00e3o adicionados ao grupo. Por exemplo: from tupy import * grupo = Group([ Image('star.png', 100, 100), Image('star.png', 150, 150) ]) def update(): grupo.x += 1 run(globals())","title":"Grupos de objetos"},{"location":"grupos/#grupos-de-objetos","text":"BaseGroup e Group s\u00e3o classes de conveni\u00eancia que permitem agrupar objetos do Tupy em um \u00fanico objeto. Por exemplo, se voc\u00ea quiser mover um grupo de objetos, basta mover o grupo que os cont\u00e9m. A classe BaseGroup possui membros privados e foi feita para ser estendida por outras classes, enquanto a classe Group funciona da mesma forma, mas com membros p\u00fablicos.","title":"Grupos de objetos"},{"location":"grupos/#basegroup","text":"Al\u00e9m dos atributos e m\u00e9todos herdados de BaseTupyObject , BaseGroup define os seguintes atributos e m\u00e9todos: _objects : lista com todos os objetos contidos no BaseGroup . Essa lista n\u00e3o deve ser alterada diretamente, e sim atrav\u00e9s dos m\u00e9todos _add , _remove e _clear . _add(obj) : adiciona um objeto \u00e0 lista de objetos contidos no BaseGroup . _remove(obj) : remove um objeto da lista de objetos contidos no BaseGroup . _clear() : remove todos os objetos da lista de objetos contidos no BaseGroup . Exemplo de uso de BaseGroup : from tupy import * class Constelacao(BaseGroup): def __init__(self): super().__init__(x, y) self._add(Image('estrela.png', 100, 100)) self._add(Image('estrela.png', 150, 150)) def update(self): self._x += 1 self._y += 1 cons = Constelacao() run(globals())","title":"BaseGroup"},{"location":"grupos/#group","text":"Group possui os mesmos atributos e m\u00e9todos, por\u00e9m p\u00fablicos. Al\u00e9m disso, Group possui x e y p\u00fablicos. O construtor de Group recebe, opcionalmente, uma lista de objetos que ser\u00e3o adicionados ao grupo. Por exemplo: from tupy import * grupo = Group([ Image('star.png', 100, 100), Image('star.png', 150, 150) ]) def update(): grupo.x += 1 run(globals())","title":"Group"},{"location":"imagens/","text":"Imagens O tipo Image \u00e9 um dos mais comuns em programas escritos para o Tupy. Ele representa uma imagem que pode ser exibida na tela. A classe Image possui os seguintes atributos: x e y : coordenadas da imagem na tela file : nome do arquivo de imagem, no formato PNG angle : \u00e2ngulo de rota\u00e7\u00e3o da imagem, em graus O Tupy busca o arquivo de imagem nos seguintes locais, em ordem: no diret\u00f3rio onde se encontra o script no subdiret\u00f3rio assets do diret\u00f3rio onde se encontra o script no diret\u00f3rio de instala\u00e7\u00e3o do pacote Tupy O Tupy j\u00e1 vem com algumas imagens de exemplo, que podem ser usadas diretamente pelo nome: star.png , star2.png , ball.png , smiley.png , drone.png . Criando uma imagem Para criar uma imagem, basta instanciar a classe Image : Image(file, x, y) Os par\u00e2metros x e y s\u00e3o opcionais; se omitidos, a imagem \u00e9 criada em uma posi\u00e7\u00e3o aleat\u00f3ria. Exemplo de c\u00f3digo: from tupy import * a = Image('star.png', 100, 200) b = Image('star2.png') # posi\u00e7\u00e3o aleat\u00f3ria b.angle = 30 run(globals()) Criando sua pr\u00f3pria classe Outra forma de criar imagens \u00e9 criando uma classe estende a classe Image . Por exemplo: from tupy import * class Star(Image): def __init__(self): self.angle = 30 a = Star() a.x = 100 a.y = 200 run(globals()) No exemplo, a classe Star herda os atributos e m\u00e9todos de Image , como x , y , file e angle . A classe Star n\u00e3o adiciona nenhum atributo ou m\u00e9todo novo, mas poderia faz\u00ea-lo. Ao ser inicializada, a estrela \u00e9 rotacionada em 30 graus. Al\u00e9m disso, a estrela \u00e9 criada em uma posi\u00e7\u00e3o aleat\u00f3ria, e em seguida a posi\u00e7\u00e3o \u00e9 alterada para (100, 200). Note que, no exemplo, n\u00e3o foi definido o nome do arquivo de imagem. Nesse caso, o Tupy procura um arquivo com o mesmo nome da classe (em min\u00fasculas), seguido de .png . Ou seja, nesse exemplo o nome do arquivo \u00e9 star.png . Se necess\u00e1rio, \u00e9 poss\u00edvel alterar o nome do arquivo, atribuindo um novo valor ao atributo file .","title":"Imagens"},{"location":"imagens/#imagens","text":"O tipo Image \u00e9 um dos mais comuns em programas escritos para o Tupy. Ele representa uma imagem que pode ser exibida na tela. A classe Image possui os seguintes atributos: x e y : coordenadas da imagem na tela file : nome do arquivo de imagem, no formato PNG angle : \u00e2ngulo de rota\u00e7\u00e3o da imagem, em graus O Tupy busca o arquivo de imagem nos seguintes locais, em ordem: no diret\u00f3rio onde se encontra o script no subdiret\u00f3rio assets do diret\u00f3rio onde se encontra o script no diret\u00f3rio de instala\u00e7\u00e3o do pacote Tupy O Tupy j\u00e1 vem com algumas imagens de exemplo, que podem ser usadas diretamente pelo nome: star.png , star2.png , ball.png , smiley.png , drone.png .","title":"Imagens"},{"location":"imagens/#criando-uma-imagem","text":"Para criar uma imagem, basta instanciar a classe Image : Image(file, x, y) Os par\u00e2metros x e y s\u00e3o opcionais; se omitidos, a imagem \u00e9 criada em uma posi\u00e7\u00e3o aleat\u00f3ria. Exemplo de c\u00f3digo: from tupy import * a = Image('star.png', 100, 200) b = Image('star2.png') # posi\u00e7\u00e3o aleat\u00f3ria b.angle = 30 run(globals())","title":"Criando uma imagem"},{"location":"imagens/#criando-sua-propria-classe","text":"Outra forma de criar imagens \u00e9 criando uma classe estende a classe Image . Por exemplo: from tupy import * class Star(Image): def __init__(self): self.angle = 30 a = Star() a.x = 100 a.y = 200 run(globals()) No exemplo, a classe Star herda os atributos e m\u00e9todos de Image , como x , y , file e angle . A classe Star n\u00e3o adiciona nenhum atributo ou m\u00e9todo novo, mas poderia faz\u00ea-lo. Ao ser inicializada, a estrela \u00e9 rotacionada em 30 graus. Al\u00e9m disso, a estrela \u00e9 criada em uma posi\u00e7\u00e3o aleat\u00f3ria, e em seguida a posi\u00e7\u00e3o \u00e9 alterada para (100, 200). Note que, no exemplo, n\u00e3o foi definido o nome do arquivo de imagem. Nesse caso, o Tupy procura um arquivo com o mesmo nome da classe (em min\u00fasculas), seguido de .png . Ou seja, nesse exemplo o nome do arquivo \u00e9 star.png . Se necess\u00e1rio, \u00e9 poss\u00edvel alterar o nome do arquivo, atribuindo um novo valor ao atributo file .","title":"Criando sua pr\u00f3pria classe"},{"location":"instalacao/","text":"Instala\u00e7\u00e3o Requisitos Para usar o Tupy, voc\u00ea precisa instalar o Python (vers\u00e3o 3.11 ou superior), bem como o gerenciador de pacotes pip . Instala\u00e7\u00e3o via pip Para instalar a \u00faltima vers\u00e3o, execute o comando: pip install git+https://github.com/rodrigorgs/tupy.git","title":"Instala\u00e7\u00e3o"},{"location":"instalacao/#instalacao","text":"","title":"Instala\u00e7\u00e3o"},{"location":"instalacao/#requisitos","text":"Para usar o Tupy, voc\u00ea precisa instalar o Python (vers\u00e3o 3.11 ou superior), bem como o gerenciador de pacotes pip .","title":"Requisitos"},{"location":"instalacao/#instalacao-via-pip","text":"Para instalar a \u00faltima vers\u00e3o, execute o comando: pip install git+https://github.com/rodrigorgs/tupy.git","title":"Instala\u00e7\u00e3o via pip"},{"location":"interface/","text":"Interface A interface gr\u00e1fica do Tupy \u00e9 composta de quatro partes principais: Barra de ferramenta (topo): cont\u00e9m bot\u00f5es para pausar/continuar, bem como um bot\u00e3o para criar novos objetos Visualiza\u00e7\u00e3o da cena (centro esquerda): exibe os objetos criados pelo programa Console (inferior esquerda): permite executar instru\u00e7\u00f5es em Python e ver o resultado Inspetor (direita): permite visualizar e alterar os objetos da cena","title":"Interface"},{"location":"interface/#interface","text":"A interface gr\u00e1fica do Tupy \u00e9 composta de quatro partes principais: Barra de ferramenta (topo): cont\u00e9m bot\u00f5es para pausar/continuar, bem como um bot\u00e3o para criar novos objetos Visualiza\u00e7\u00e3o da cena (centro esquerda): exibe os objetos criados pelo programa Console (inferior esquerda): permite executar instru\u00e7\u00f5es em Python e ver o resultado Inspetor (direita): permite visualizar e alterar os objetos da cena","title":"Interface"},{"location":"tupyobject/","text":"BaseTupyObject BaseTupyObject \u00e9 a classe base de todos os objetos do Tupy, que s\u00e3o os objetos que aparecem na cena. Ela define os atributos e m\u00e9todos comuns a todos os objetos do Tupy. Algumas subclasses de BaseTupyObject s\u00e3o BaseImage , Image , Rectangle , Oval e Label . As subclasses podem definir atributos e m\u00e9todos adicionais, mas todas elas herdam os atributos e m\u00e9todos de BaseTupyObject . Atributos _x , _y : posi\u00e7\u00e3o do objeto na cena. Cada subclasse define o ponto de refer\u00eancia usado para posicionar o objeto. Por exemplo, na classe Rectangle , o ponto de refer\u00eancia \u00e9 o canto superior esquerdo do ret\u00e2ngulo. Na classe Image , o ponto de refer\u00eancia \u00e9 o centro da imagem. _width , _height : largura e altura do objeto. Se o objeto n\u00e3o for retangular, ainda assim ele deve definir a largura e a altura de um ret\u00e2ngulo que o cont\u00e9m. M\u00e9todos _hide() , _show() : esconde e mostra o objeto na cena. _contains_point(x, y) : m\u00e9todo de conveni\u00eancia que indica se o ponto (x, y) est\u00e1 dentro do ret\u00e2ngulo formado por _x , _y , _width , _height . _collides_with(outro) : m\u00e9todo de conveni\u00eancia que indica se o objeto colide com outro objeto. O objeto passado como par\u00e2metro deve ser uma inst\u00e2ncia de BaseTupyObject ou de uma de suas subclasses.","title":"BaseTupyObject"},{"location":"tupyobject/#basetupyobject","text":"BaseTupyObject \u00e9 a classe base de todos os objetos do Tupy, que s\u00e3o os objetos que aparecem na cena. Ela define os atributos e m\u00e9todos comuns a todos os objetos do Tupy. Algumas subclasses de BaseTupyObject s\u00e3o BaseImage , Image , Rectangle , Oval e Label . As subclasses podem definir atributos e m\u00e9todos adicionais, mas todas elas herdam os atributos e m\u00e9todos de BaseTupyObject .","title":"BaseTupyObject"},{"location":"tupyobject/#atributos","text":"_x , _y : posi\u00e7\u00e3o do objeto na cena. Cada subclasse define o ponto de refer\u00eancia usado para posicionar o objeto. Por exemplo, na classe Rectangle , o ponto de refer\u00eancia \u00e9 o canto superior esquerdo do ret\u00e2ngulo. Na classe Image , o ponto de refer\u00eancia \u00e9 o centro da imagem. _width , _height : largura e altura do objeto. Se o objeto n\u00e3o for retangular, ainda assim ele deve definir a largura e a altura de um ret\u00e2ngulo que o cont\u00e9m.","title":"Atributos"},{"location":"tupyobject/#metodos","text":"_hide() , _show() : esconde e mostra o objeto na cena. _contains_point(x, y) : m\u00e9todo de conveni\u00eancia que indica se o ponto (x, y) est\u00e1 dentro do ret\u00e2ngulo formado por _x , _y , _width , _height . _collides_with(outro) : m\u00e9todo de conveni\u00eancia que indica se o objeto colide com outro objeto. O objeto passado como par\u00e2metro deve ser uma inst\u00e2ncia de BaseTupyObject ou de uma de suas subclasses.","title":"M\u00e9todos"}]}